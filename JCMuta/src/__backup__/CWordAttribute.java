package __backup__;

/**
 * The predefined attribute that describes the feature of the word under analysis, which 
 * defines the following mapping from object to the word of attributes they describe.<br>
 * <br>
 * <code>
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	CirNode word																					|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	declarator			|	[expression, reference, identifier, #name] 	(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	identifier			|	[expression, reference, identifier, #name] 	(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	implicator			|	[expression, reference, register]			(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	return_ptr			|	[expression, reference, returning]			(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	defer_expr			|	[expression, reference, deference]			(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	field_expr			|	[expression, reference, field]				(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	const_expr			|	[expression, value, constant, #value]		(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	string_literal		|	[expression, value, literal, #text]			(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	addr_expr			|	[expression, value, address]				(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	cast_expr			|	[expression, value, casting, assignment]	(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	wait_expr			|	[expression, value, returning]				(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	default_val			|	[expression, value, initial]				(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	initial_body		|	[expression, value, initial, sequence]		(type)						|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	comp_expr			|	[expression, value, @operator]				(type)						|
 * 	|						|	@operator	|-- {arith_neg, bitws_rsv, logic_not}						|
 * 	|						|	@operator	|-- {arith_add, arith_sub, arith_mul, arith_div, arith_mod}	|
 * 	|						|	@operator	|-- {bitws_and, bitws_ior, bitws_xor, bitws_lsh, bitws_rsh}	|
 * 	|						|	@operator	|-- {smaller_tn, equal_with}								|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	field				|	[identifier, field]														|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	label				|	[identifier, skiping]													|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	bin_assign_stmt		|	[statement, assignment, value]											|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	inc_assign_stmt		|	[statement, assignment, increment]										|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	ini_assign_stmt		|	[statement, assignment, initial]										|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	sav_assign_stmt		|	[statement, assignment, register]										|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	| 	ret_assign_stmt		|	[statement, assignment, returning]										|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	wat_assign_stmt		|	[statement, assignment, calling]										|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	goto_statement		|	[statement, transition, skiping]										|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	if_statement		|	[statement, transition, if]												|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	case_statement		|	[statement, transition, case]											|
 * 	+-----------------------+---------------------------------------------------------------------------+
 * 	|	call_statement		|	[statement, transition, calling]										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  <br>
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	Data Type Word		|																			|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	void				|	(void)																	|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	bool				|	(number, boolean)														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	char				|	(number, integer, character (unsigned))									|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	short				|	(number, integer, short, (unsigned))									|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	int					|	(number, integer, (unsigned))											|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	long				|	(number, integer, long, (unsigned))										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	llong				|	(number, integer, long, lont, (unsigned))								|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	float				|	(number, real, short)													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	double				|	(number, real)															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	ldouble				|	(number, real, long)													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	float_complex		|	(number, real, short, complex)											|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	ldouble_imaginary	|	(number, real, long, imaginary)											|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	gnu_va_list			|	(calling, sequence)														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	array_type			|	(address, sequence, (etype))											|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	pointer_type		|	(address, (ptype))														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	function_type		|	(address, calling, (rtype))												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	struct name			|	(struct, #name)															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	union name			|	(union, #name)															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	enum name			|	(number, integer)														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  <br>
 *  +-----------------------+---------------------------------------------------------------------------+
 *  | 	Relation Word		|																			|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	exec_a				|	[calling, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	exec_c				|	[condition, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	exec_e				|	[expression, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	exec_t				|	[true, on/by]															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	exec_f				|	[false, on/by]															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	exec_p				|	[argument, #index, on/by]												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	pas_xx				|	[assignment, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	gen_af				|	[operand, #index, on/by]												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	gen_fw				|	[returning, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	defer_expr.c0		|	[address, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	field_expr.c0		|	[sequence, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	field_expr.c1		|	[field, on/by]															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	addr_expr.c0		|	[reference, on/by]														|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	cast_expr.c0		|	[value, on/by]															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	initial_body.ck		|	[element, #index, on/by]												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	comp_expr.ck		|	[operand, #index, on/by]												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  <br>
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	Semantic-Node-Word	|																			|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	cover(stmt)			|	{cover, 1}																|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	repeat(stmt, int)	|	{cover, #int}															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	execute(stmt)		|	{execute}																|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	non_execute(stmt)	|	{logic_not, execute}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	traping(stmt)		|	{traping}																|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	equal_with(e, c)	|	{equal_with, #const}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	equal_with(e, e)	|	{equal_with}															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	smaller_tn(e, c)	|	{smaller_tn, #const}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	smaller_tn(e, e)	|	{smaller_tn}															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	smaller_eq(e, c)	|	{smaller_tn, equal_with, #const}										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	smaller_eq(e, e)	|	{smaller_tn, equal_with}												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	greater_tn(e, c)	|	{logic_not, smaller_tn, #const}											|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	greater_tn(e, e)	|	{logic_not, smaller_tn}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	greater_eq(e, c)	|	{logic_not, smaller_tn, equal_with, #const}								|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	greater_eq(e, e)	|	{logic_not, smaller_tn, equal_with}										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	in_range(e, str)	|	{in, #string}															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	not_in_range(e, str)|	{logic_not, in, #string}												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	bit_intersc(e, e)	|	{bitws_and, logic_not, equal_with, 0}									|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	bit_exclude(e, e)	|	{bitws_and, equal_with, 0}												|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	bit_include(e, e)	|	{bitws_and, equal_with}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	bno_include(e, e)	|	{bitws_and, logic_not, equal_with}										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	is_multiply(e, e)	|	{arith_mul, integer, equal_with}										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	is_negative(e, e)	|	{arith_neg, equal_with}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	not_negative(e, e)	|	{arith_neg, logic_not, equal_with}										|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	chg_val(e)			|	{assignment}															|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	set_val(e, c)		|	{assignment, #const}													|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	neg_val(e, c)		|	{#operator}																|
 *  +-----------------------+---------------------------------------------------------------------------+
 *  |	inc_val(e, i)		|	{increment, #int}														|
 *  +-----------------------+---------------------------------------------------------------------------+
 * </code>
 * <br>
 * @author yukimula
 *
 */
public enum CWordAttribute {
	/* expression */
	expression,
	reference,
	value,
	identifier,
	register,
	returning,
	deference,
	field,
	constant,
	literal,
	address,
	casting,
	initial,
	sequence,
	/* operator */
	arith_neg,
	bitws_rsv,
	logic_not,
	arith_add,
	arith_sub,
	arith_mul,
	arith_div,
	arith_mod,
	bitws_and,
	bitws_ior,
	bitws_xor,
	bitws_lsh,
	bitws_rsh,
	smaller_tn,
	equal_with,
	/* statement */
	statement,
	assignment,
	increment,
	calling,
	transition,
	if_kw,
	case_kw,
	condition,
	skiping,
	dead,
	/* data type */
	void_kw,
	number, 
	boolean_kw,
	integer,
	character,
	short_kw,
	long_kw,
	unsigned,
	real,
	complex,
	imaginary,
	struct,
	union,
	/* relation */
	true_kw,
	false_kw,
	argument,
	operand,
	element,
	on,
	by,
	/* mutation-word */
	cover,
	execute,
	traping,
	in,
}
