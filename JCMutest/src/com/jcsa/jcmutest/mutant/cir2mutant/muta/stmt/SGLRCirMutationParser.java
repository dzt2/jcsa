package com.jcsa.jcmutest.mutant.cir2mutant.muta.stmt;

import java.util.Map;

import com.jcsa.jcmutest.mutant.cir2mutant.cerr.CirConstraint;
import com.jcsa.jcmutest.mutant.cir2mutant.cerr.CirMutations;
import com.jcsa.jcmutest.mutant.cir2mutant.cerr.CirStateError;
import com.jcsa.jcmutest.mutant.cir2mutant.muta.CirMutationParser;
import com.jcsa.jcmutest.mutant.mutation.AstMutation;
import com.jcsa.jcparse.lang.astree.AstNode;
import com.jcsa.jcparse.lang.irlang.CirTree;
import com.jcsa.jcparse.lang.irlang.graph.CirExecution;
import com.jcsa.jcparse.lang.irlang.graph.CirExecutionFlow;
import com.jcsa.jcparse.lang.irlang.graph.CirExecutionFlowType;
import com.jcsa.jcparse.lang.irlang.stmt.CirStatement;

public class SGLRCirMutationParser extends CirMutationParser {

	@Override
	protected CirStatement get_location(CirTree cir_tree, AstMutation mutation) throws Exception {
		return this.get_beg_statement(cir_tree, mutation.get_location());
	}

	@Override
	protected void generate_infections(CirMutations mutations, CirTree cir_tree, CirStatement statement,
			AstMutation mutation, Map<CirStateError, CirConstraint> infections) throws Exception {
		CirExecution source = cir_tree.get_localizer().get_execution(statement);
		CirExecutionFlow orig_flow = source.get_ou_flow(0);
		
		CirStatement next_statement = this.get_beg_statement(cir_tree, (AstNode) mutation.get_parameter());
		CirExecution target = cir_tree.get_localizer().get_execution(next_statement);
		CirExecutionFlow muta_flow = CirExecutionFlow.virtual_flow(CirExecutionFlowType.next_flow, source, target);
		
		infections.put(mutations.flow_error(orig_flow, muta_flow), mutations.expression_constraint(statement, Boolean.TRUE, true));
	}

}
